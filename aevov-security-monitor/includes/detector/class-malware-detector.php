<?php
/**
 * Malware Detector - Ghost-Inspired Security Detection
 *
 * Implements malware detection techniques inspired by the Ghost project:
 * - Shellcode pattern recognition
 * - Suspicious function detection
 * - Code injection indicators
 * - Memory manipulation patterns
 * - YARA signature matching
 * - Behavioral analysis
 *
 * Adapted for PHP/WordPress environment from Ghost's Rust implementation
 *
 * @package AevovSecurityMonitor
 * @since 1.0.0
 */

namespace AevovSecurityMonitor;

if (!defined('ABSPATH')) {
    exit;
}

/**
 * Class MalwareDetector
 */
class MalwareDetector {

    /**
     * Known malware signatures (hex patterns)
     */
    const SHELLCODE_PATTERNS = [
        // Common x86 shellcode patterns
        '/\\x90{10,}/',                    // NOP sled
        '/\\xeb.{1,20}\\xcd\\x80/',        // jmp + syscall
        '/\\x31\\xc0\\x50\\x68/',          // XOR EAX, PUSH, PUSH (common prologue)
        '/\\xcc{5,}/',                     // INT3 sled
        '/\\x90\\x90\\x90\\xeb/',          // NOP + short jump
        // Common webshell patterns
        '/eval\\s*\\(\\s*base64_decode/',
        '/gzinflate\\s*\\(\\s*base64_decode/',
        '/assert\\s*\\(\\s*base64_decode/',
        '/preg_replace\\s*\\(.*\\x2Fe/i',  // preg_replace with /e modifier
        '/create_function\\s*\\(.*eval/',
        '/system\\s*\\(\\s*\\$_(?:GET|POST|REQUEST)/',
        '/passthru\\s*\\(\\s*\\$_(?:GET|POST|REQUEST)/',
        '/shell_exec\\s*\\(\\s*\\$_(?:GET|POST|REQUEST)/',
        '/`\\s*\\$_(?:GET|POST|REQUEST)/', // Backtick execution
    ];

    /**
     * Suspicious PHP functions
     */
    const DANGEROUS_FUNCTIONS = [
        'eval', 'assert', 'system', 'exec', 'shell_exec', 'passthru', 'popen',
        'proc_open', 'pcntl_exec', 'create_function', 'include', 'require',
        'include_once', 'require_once', 'file_get_contents', 'file_put_contents',
        'fopen', 'readfile', 'curl_exec', 'curl_multi_exec', 'parse_str',
        'mb_parse_str', 'extract', 'putenv', 'ini_set', 'mail', 'filter_var',
        'filter_var_array', 'uasort', 'uksort', 'usort', 'preg_replace',
        'preg_filter', 'mb_ereg_replace', 'ob_start'
    ];

    /**
     * Known malware file signatures
     */
    const MALWARE_SIGNATURES = [
        'c99_shell' => '/c99shell|r57shell|Safe0ver|FilesMan|mysql_tool/',
        'wso_shell' => '/wso\s*=\s*array|WSO_VERSION|wso_login/',
        'b374k_shell' => '/b374k|b374kpass|@eval\(gzuncompress\(/',
        'web_backdoor' => '/backdoor|FilesMan|php_uname|whoami/',
        'crypto_miner' => '/monero|cryptonight|stratum\+tcp|xmr-stak/',
        'botnet' => '/botnet|ddos|udpflood|syn_flood/',
        'ransomware' => '/encrypt.*decrypt|ransom|\.encrypted|pay.*bitcoin/',
        'keylogger' => '/keylog|keystroke|password.*capture/',
        'rootkit' => '/rootkit|hide.*process|kernel.*inject/',
    ];

    /**
     * Obfuscation detection patterns
     */
    const OBFUSCATION_PATTERNS = [
        'base64_heavy' => '/(?:base64_decode.*){3,}/',
        'char_code' => '/chr\s*\(\s*\d+\s*\).*{10,}/',
        'hex_encoding' => '/\\x[0-9a-f]{2}.*{20,}/',
        'variable_variables' => '/\$\$+[a-zA-Z_]/',
        'dynamic_function' => '/\$[a-zA-Z_]+\s*\(/',
        'string_rot13' => '/str_rot13/',
        'gzdeflate' => '/gz(?:deflate|inflate|uncompress|compress)/',
    ];

    /**
     * YARA engine instance
     *
     * @var YaraEngine
     */
    private $yara_engine;

    /**
     * Constructor
     */
    public function __construct() {
        $this->yara_engine = new YaraEngine();
    }

    /**
     * Scan file for malware
     *
     * @param string $file_path Path to file
     * @return array Scan result
     */
    public function scan_file($file_path) {
        if (!file_exists($file_path)) {
            return [
                'threat_detected' => false,
                'error' => 'File not found'
            ];
        }

        $result = [
            'file' => $file_path,
            'size' => filesize($file_path),
            'threat_detected' => false,
            'threats' => [],
            'risk_score' => 0,
            'analysis' => []
        ];

        // Read file content
        $content = file_get_contents($file_path);

        // 1. Shellcode detection
        $shellcode_threats = $this->detect_shellcode($content);
        if (!empty($shellcode_threats)) {
            $result['threats'] = array_merge($result['threats'], $shellcode_threats);
            $result['risk_score'] += 30;
        }

        // 2. Malware signature matching
        $signature_matches = $this->match_signatures($content);
        if (!empty($signature_matches)) {
            $result['threats'] = array_merge($result['threats'], $signature_matches);
            $result['risk_score'] += 40;
        }

        // 3. Dangerous function detection
        $dangerous_funcs = $this->detect_dangerous_functions($content);
        if (!empty($dangerous_funcs)) {
            $result['analysis']['dangerous_functions'] = $dangerous_funcs;
            $result['risk_score'] += count($dangerous_funcs) * 2;
        }

        // 4. Obfuscation detection
        $obfuscation = $this->detect_obfuscation($content);
        if ($obfuscation['score'] > 0) {
            $result['analysis']['obfuscation'] = $obfuscation;
            $result['risk_score'] += $obfuscation['score'];
        }

        // 5. YARA rule matching
        if (get_option('aevov_security_yara_enabled', true)) {
            $yara_matches = $this->yara_engine->scan($file_path);
            if (!empty($yara_matches)) {
                $result['threats'] = array_merge($result['threats'], $yara_matches);
                $result['risk_score'] += 50;
            }
        }

        // 6. Behavioral analysis
        $behavioral = $this->analyze_behavior($content);
        if ($behavioral['suspicious']) {
            $result['analysis']['behavioral'] = $behavioral;
            $result['risk_score'] += $behavioral['score'];
        }

        // Determine if threat detected
        $result['threat_detected'] = $result['risk_score'] >= 30;

        if ($result['threat_detected']) {
            $result['severity'] = $this->calculate_severity($result['risk_score']);
            $result['mitre_technique'] = $this->map_to_mitre($result);
        }

        return $result;
    }

    /**
     * Detect shellcode patterns
     *
     * @param string $content File content
     * @return array Detected threats
     */
    private function detect_shellcode($content) {
        $threats = [];

        foreach (self::SHELLCODE_PATTERNS as $pattern) {
            if (preg_match($pattern, $content, $matches)) {
                $threats[] = [
                    'type' => 'shellcode',
                    'pattern' => $pattern,
                    'match' => bin2hex(substr($matches[0], 0, 50)),
                    'severity' => 'critical'
                ];
            }
        }

        return $threats;
    }

    /**
     * Match malware signatures
     *
     * @param string $content File content
     * @return array Detected threats
     */
    private function match_signatures($content) {
        $threats = [];

        foreach (self::MALWARE_SIGNATURES as $family => $pattern) {
            if (preg_match($pattern, $content, $matches)) {
                $threats[] = [
                    'type' => 'malware_signature',
                    'family' => $family,
                    'pattern' => $pattern,
                    'match' => substr($matches[0], 0, 100),
                    'severity' => 'critical'
                ];
            }
        }

        return $threats;
    }

    /**
     * Detect dangerous function usage
     *
     * @param string $content File content
     * @return array Dangerous functions found
     */
    private function detect_dangerous_functions($content) {
        $found = [];

        foreach (self::DANGEROUS_FUNCTIONS as $func) {
            if (preg_match('/\b' . preg_quote($func, '/') . '\s*\(/', $content, $matches, PREG_OFFSET_CAPTURE)) {
                $found[] = [
                    'function' => $func,
                    'position' => $matches[0][1],
                    'context' => $this->get_context($content, $matches[0][1], 50)
                ];
            }
        }

        return $found;
    }

    /**
     * Detect code obfuscation
     *
     * @param string $content File content
     * @return array Obfuscation analysis
     */
    private function detect_obfuscation($content) {
        $result = [
            'detected' => false,
            'score' => 0,
            'techniques' => []
        ];

        foreach (self::OBFUSCATION_PATTERNS as $technique => $pattern) {
            if (preg_match($pattern, $content)) {
                $result['techniques'][] = $technique;
                $result['score'] += 10;
            }
        }

        // Additional heuristics
        $lines = explode("\n", $content);

        // Check for extremely long lines (often obfuscated)
        foreach ($lines as $line) {
            if (strlen($line) > 1000) {
                $result['techniques'][] = 'long_lines';
                $result['score'] += 5;
                break;
            }
        }

        // Check for high entropy (random-looking strings)
        $entropy = $this->calculate_entropy($content);
        if ($entropy > 5.5) {
            $result['techniques'][] = 'high_entropy';
            $result['score'] += 15;
        }

        $result['detected'] = $result['score'] > 0;

        return $result;
    }

    /**
     * Analyze behavioral patterns
     *
     * @param string $content File content
     * @return array Behavioral analysis
     */
    private function analyze_behavior($content) {
        $result = [
            'suspicious' => false,
            'score' => 0,
            'behaviors' => []
        ];

        // Check for network communication
        if (preg_match('/(curl|fsockopen|socket_connect|stream_socket_client)/', $content)) {
            $result['behaviors'][] = 'network_communication';
            $result['score'] += 10;
        }

        // Check for file operations
        if (preg_match('/(file_put_contents|fwrite|unlink|rmdir)/', $content)) {
            $result['behaviors'][] = 'file_operations';
            $result['score'] += 5;
        }

        // Check for database operations
        if (preg_match('/(mysql_query|mysqli_query|pg_query|exec\s*\(.*SELECT)/', $content)) {
            $result['behaviors'][] = 'database_access';
            $result['score'] += 5;
        }

        // Check for code execution
        if (preg_match('/(eval|assert|create_function|preg_replace.*\/e)/', $content)) {
            $result['behaviors'][] = 'code_execution';
            $result['score'] += 20;
        }

        // Check for information gathering
        if (preg_match('/(phpinfo|get_current_user|php_uname|system\s*\(.*uname)/', $content)) {
            $result['behaviors'][] = 'information_gathering';
            $result['score'] += 10;
        }

        // Check for privilege escalation attempts
        if (preg_match('/(chmod\s*\(.*777|chown|su\s|sudo)/', $content)) {
            $result['behaviors'][] = 'privilege_escalation';
            $result['score'] += 15;
        }

        $result['suspicious'] = $result['score'] > 10;

        return $result;
    }

    /**
     * Calculate string entropy (randomness measure)
     *
     * @param string $string String to analyze
     * @return float Entropy value
     */
    private function calculate_entropy($string) {
        $len = strlen($string);
        if ($len === 0) {
            return 0;
        }

        $char_counts = count_chars($string, 1);
        $entropy = 0;

        foreach ($char_counts as $count) {
            $p = $count / $len;
            $entropy -= $p * log($p, 2);
        }

        return $entropy;
    }

    /**
     * Get context around a position in content
     *
     * @param string $content Content
     * @param int $position Position
     * @param int $length Context length
     * @return string Context
     */
    private function get_context($content, $position, $length) {
        $start = max(0, $position - $length);
        $context = substr($content, $start, $length * 2);
        return addcslashes($context, "\0..\37\177..\377");
    }

    /**
     * Calculate threat severity
     *
     * @param int $risk_score Risk score
     * @return string Severity level
     */
    private function calculate_severity($risk_score) {
        if ($risk_score >= 70) {
            return 'critical';
        } elseif ($risk_score >= 50) {
            return 'high';
        } elseif ($risk_score >= 30) {
            return 'medium';
        } else {
            return 'low';
        }
    }

    /**
     * Map detected threats to MITRE ATT&CK techniques
     *
     * @param array $result Scan result
     * @return string|null MITRE technique ID
     */
    private function map_to_mitre($result) {
        // Check threat types and behaviors
        foreach ($result['threats'] as $threat) {
            if ($threat['type'] === 'shellcode') {
                return 'T1055'; // Process Injection
            } elseif ($threat['type'] === 'malware_signature') {
                switch ($threat['family']) {
                    case 'ransomware':
                        return 'T1486'; // Data Encrypted for Impact
                    case 'keylogger':
                        return 'T1056'; // Input Capture
                    case 'rootkit':
                        return 'T1014'; // Rootkit
                    case 'crypto_miner':
                        return 'T1496'; // Resource Hijacking
                    default:
                        return 'T1059'; // Command and Scripting Interpreter
                }
            }
        }

        // Check behaviors
        if (!empty($result['analysis']['behavioral']['behaviors'])) {
            $behaviors = $result['analysis']['behavioral']['behaviors'];

            if (in_array('code_execution', $behaviors)) {
                return 'T1059.004'; // Command and Scripting Interpreter: Unix Shell
            } elseif (in_array('privilege_escalation', $behaviors)) {
                return 'T1548'; // Abuse Elevation Control Mechanism
            } elseif (in_array('network_communication', $behaviors)) {
                return 'T1071'; // Application Layer Protocol
            }
        }

        return null;
    }

    /**
     * Scan directory recursively
     *
     * @param string $directory Directory path
     * @param array $options Scan options
     * @return array Scan results
     */
    public function scan_directory($directory, $options = []) {
        if (!is_dir($directory)) {
            return ['error' => 'Directory not found'];
        }

        $results = [
            'directory' => $directory,
            'files_scanned' => 0,
            'threats_found' => 0,
            'threats' => [],
            'started_at' => time()
        ];

        $iterator = new \RecursiveIteratorIterator(
            new \RecursiveDirectoryIterator($directory, \RecursiveDirectoryIterator::SKIP_DOTS),
            \RecursiveIteratorIterator::SELF_FIRST
        );

        foreach ($iterator as $file) {
            if ($file->isFile()) {
                // Skip large files (>10MB by default)
                $max_size = $options['max_file_size'] ?? 10485760;
                if ($file->getSize() > $max_size) {
                    continue;
                }

                // Scan file
                $scan_result = $this->scan_file($file->getPathname());
                $results['files_scanned']++;

                if ($scan_result['threat_detected']) {
                    $results['threats_found']++;
                    $results['threats'][] = $scan_result;
                }

                // Limit for performance
                if ($results['files_scanned'] >= ($options['max_files'] ?? 10000)) {
                    break;
                }
            }
        }

        $results['completed_at'] = time();
        $results['duration'] = $results['completed_at'] - $results['started_at'];

        return $results;
    }
}
